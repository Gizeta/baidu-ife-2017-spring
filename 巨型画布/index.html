<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        body {
            background: lightgray;
        }
        canvas {
            max-width: 600px;
            max-height: 6480px;
            background: white;
        }
        #source {
            display: none;
        }
    </style>
</head>
<body>
    <div>
        <button onclick="javascript:gen();">generate new image</button>
        <button onclick="javascript:canMove();">move</button>
        <button onclick="javascript:canDraw();">draw</button>
        <button onclick="javascript:clearPath();">clear</button>
    </div>
    <img id="source" />
    <canvas width="600" height="480">
    </canvas>
    <script>
        let canvas = document.querySelector("canvas");
        let ctx = canvas.getContext("2d");
        let isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

        let scope = {
            x: 0,
            y: 0,
            img: null,
            lines: [],
            move: false,
            draw: false,
            animationId: null,
            trigger: false,
            picDrag: false,
            thumbDrag: false,
            lastMouseX: 0,
            lastMouseY: 0,
            lastX: 0,
            lastY: 0,
        }

        function canMove() {
            canvas.style.cursor = isFirefox ? "grab" : "move";
            scope.move = true;
            scope.draw = false;
        }

        function canDraw() {
            canvas.style.cursor = "crosshair";
            scope.move = false;
            scope.draw = true;
        }

        function clearPath() {
            scope.lines = [];
        }

        function gen() {
            let colors = ['#D13B00', '#E82A0C', '#E80C0F', '#E8690C', '#E88709'];
            let triangleSize = 150;
            let trianglesHigh = 25;
            let trianglesWide = 25;
            let skew = 1.73205;
            let width = triangleSize * trianglesWide * skew;
            let height = triangleSize * trianglesHigh;
            let url = "<svg xmlns='http://www.w3.org/2000/svg' width='" + width + "' height='" + height + "'>";

            function getColor() {
                return colors[Math.floor(Math.random() * colors.length)];
            }

            for (i = -1; i <= trianglesWide; i += 1) {
                for (j = -0.5; j <= trianglesHigh; j += 0.5) {
                    let v = (i + (j % 1)) * triangleSize * skew;
                    let w = j * triangleSize;
                    let x = v + (triangleSize * skew);
                    let y = w + triangleSize;
                    let a = v + "," + w;
                    let b = x + "," + w;
                    let c = (v + x) / 2 + "," + ((w + y) / 2);
                    let d = v + "," + y;
                    let e = x + "," + y;

                    url += "<polygon fill='" + getColor() + "' points='" + a + " " + c + " " + d + " " + "' />";
                    url += "<polygon fill='" + getColor() + "' points='" + b + " " + c + " " + e + " " + "' />";
                }
            }

            url += "</svg>";
            url = "data:image/svg+xml;base64," + window.btoa(url);

            document.getElementById("source").src = url;

            initCanvas();
        }

        function initCanvas() {
            let img = document.getElementById("source");

            if (scope.animationId) {
                cancelAnimationFrame(scope.animationId);
                scope.animationId = null;
            }

            img.onload = function() {
                scope.img = img;
                clearPath();
                draw();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            scope.animationId = null;

            ctx.drawImage(scope.img, scope.x, scope.y, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);            

            ctx.beginPath();
            // draw lines
            for (let line of scope.lines) {
                if (line.length > 4) {
                    let i = 0;
                    let offsetX = line[i++] - scope.x;
                    let offsetY = line[i++] - scope.y;
                    ctx.moveTo(offsetX + line[i++], offsetY + line[i++]);
                    while (line[i] != null) {
                        ctx.lineTo(offsetX + line[i++], offsetY + line[i++]);
                    }
                }
            }
            ctx.stroke();
            ctx.closePath();

            // thumbnail
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fillRect(canvas.width - 182, canvas.height - 146, 182, 146);
            ctx.drawImage(scope.img, 0, 0, scope.img.width, scope.img.height, canvas.width - 180, canvas.height - 144, 180, 144);
            ctx.strokeStyle = 'black';
            ctx.strokeRect(canvas.width - 180 + scope.x * 180 / scope.img.width, canvas.height - 144 + scope.y * 144 / scope.img.height, 180 * canvas.width / scope.img.width, 144 * canvas.height / scope.img.height);

            // draw line in thumbnail
            ctx.beginPath();
            for (let line of scope.lines) {
                if (line.length > 4) {
                    let i = 0;
                    let offsetX = line[i++];
                    let offsetY = line[i++];
                    ctx.moveTo(canvas.width - 180 + 180 * (offsetX + line[i++]) / scope.img.width, canvas.height - 144 + 144 * (offsetY + line[i++]) / scope.img.height);
                    while (line[i] != null) {
                        ctx.lineTo(canvas.width - 180 + 180 * (offsetX + line[i++]) / scope.img.width, canvas.height - 144 + 144 * (offsetY + line[i++]) / scope.img.height);
                    }
                }
            }
            ctx.stroke();
            ctx.closePath();

            scope.animationId = requestAnimationFrame(draw);
        }

        canvas.onmousedown = function(e) {
            scope.trigger = true;
            if (canvas.setCapture)
                canvas.setCapture();

            let posX = e.clientX - canvas.offsetLeft;
            let posY = e.clientY - canvas.offsetTop;

            if (scope.move) {
                // click thumbnail
                if (posX > canvas.width - 180 && posY > canvas.height - 144) {
                    scope.thumbDrag = true;
                    scope.picDrag = false;
                    
                    // jump
                    if (scope.move) {
                        posX -= canvas.width - 180;
                        posY -= canvas.height - 144;
                        scope.x = posX / 180 * scope.img.width - canvas.width / 2;
                        scope.y = posY / 144 * scope.img.height - canvas.height / 2;

                        if (scope.x < 0) scope.x = 0;
                        if (scope.x > scope.img.width - canvas.width) scope.x = scope.img.width - canvas.width;
                        if (scope.y < 0) scope.y = 0;
                        if (scope.y > scope.img.height - canvas.height) scope.y = scope.img.height - canvas.height;
                    }
                } else {
                    scope.picDrag = true;
                    scope.thumbDrag = false;

                    scope.lastMouseX = e.clientX;
                    scope.lastMouseY = e.clientY;
                    scope.lastX = scope.x;
                    scope.lastY = scope.y;
                }
            } else if (scope.draw) {
                scope.lines.push([])
                scope.lines[scope.lines.length - 1].push(scope.x, scope.y);
                scope.lines[scope.lines.length - 1].push(posX, posY);
            }
        };
        canvas.onmousemove = function(e) {
            if (!scope.trigger) return false;

            if (scope.move) {
                if (scope.picDrag) {
                    let offsetX = -canvas.width * (e.clientX - scope.lastMouseX) / window.screen.width;
                    let offsetY = -canvas.height * (e.clientY - scope.lastMouseY) / window.screen.height;

                    if (scope.lastX + offsetX >= 0 && scope.lastX + offsetX <= scope.img.width - canvas.width) {
                        scope.x = scope.lastX + offsetX;
                    }
                    if (scope.lastY + offsetY >= 0 && scope.lastY + offsetY <= scope.img.height - canvas.height) {
                        scope.y = scope.lastY + offsetY;
                    }
                } else if (scope.thumbDrag) {
                    let posX = e.clientX - canvas.offsetLeft - (canvas.width - 180);
                    let posY = e.clientY - canvas.offsetTop - (canvas.height - 144);

                    scope.x = posX / 180 * scope.img.width - canvas.width / 2;
                    scope.y = posY / 144 * scope.img.height - canvas.height / 2;

                    if (scope.x < 0) scope.x = 0;
                    if (scope.x > scope.img.width - canvas.width) scope.x = scope.img.width - canvas.width;
                    if (scope.y < 0) scope.y = 0;
                    if (scope.y > scope.img.height - canvas.height) scope.y = scope.img.height - canvas.height;
                }
            } else if (scope.draw) {
                let posX = e.clientX - canvas.offsetLeft;
                let posY = e.clientY - canvas.offsetTop;
                scope.lines[scope.lines.length - 1].push(posX, posY);
            }
        };
        canvas.onmouseup = function(e) {
            scope.trigger = false;
            if (canvas.releaseCapture)
                canvas.releaseCapture();
        };
        if (!canvas.setCapture) {
            canvas.onmouseleave = function(e) {
                scope.trigger = false;
            };
        }
    </script>
</body>
</html>